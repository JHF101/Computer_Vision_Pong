from textfileReader import readTextfile, writeTextfile
import time
from convolution import seperableConvolution
import math
from pprint import pp, pprint
import numpy as np
from numpyEquivelant import transpose, pad
import matplotlib.pyplot as plt
from deprecated import deprecated
import cv2

def GaussianBlur(I, w_h, sigma):
    """
    Gaussian blurring function that results from specific 
    gaussian kernel

    Parameters
    ----------
        I : list[list[int]] 2D array(the image)
        w_h : width and height dimension of kernel in a tuple

    Returns
    -------
        A 2-D array (the Gaussian Blurred image)

    Description:
        
        Gaussian Kernel is generated by 
        G(x,y)= (1/(2*pi*sigma**2))*exp(-(x**2 + y**2)/(2*sigma**2))

    Note: If the kernel is finalised, then you can have a fixed kernel
    https://softwarebydefault.com/2013/06/08/calculating-gaussian-kernels/
    """
    @deprecated
    def kernelGenerationMath(x, y, sig):
        # Mathematical Formualtion
        return (1/(2*math.pi*sig**2)) * math.exp(-(x**2 + y**2)/(2*sig**2))
    # Setting up a 2D the array of Gaussian Kernel
    """
    for y in range(W):
        # Temp array for the
        row = [] 
        for x in range(W):
            row.append(kernelGenerationMath(x-mean,y-mean,sigma))
        kernel.append(row)
    """
    # ---------------------------------------------------------------------- #
    def kernelGeneration(i,ksize,sigma):
        # OpenCV formulation
        return math.exp((-(i-(ksize-1)/2)**2) / (2*sigma**2))
    
    G_v = [] # Vertical Kernel
    G_h = [] # Horizontal Kernel
    W = w_h[0] # Kernel size

    # If sigma is non-positive this is the calculation that follows
    if sigma<=0:
        sigma =0.3*((W-1)*0.5-1)+0.8

    # First kernel
    for x in range(W):
        temp = kernelGeneration(x, W, sigma)
        G_v.append([temp])
        # Second kernel - is just the transpose of the first matrix
        G_h.append(temp)

    # Normalising Kernel
    alpha = sum(G_h)

    # Resulting kernel
    for x in range(W):
        G_v[x] = [round(G_v[x][0]*(1/alpha),8)]
        # Second kernel - is just the transpose of the first matrix
        G_h[x] = round(G_h[x]*(1/alpha),8)
    
    # Assumptions, we are assuming that we are only getting in a grayscale image
    # Getting the image dimensions
    width = len(I[0])
    height = len(I)
    """
     Feature map calculation is as follows:
     (W - F + 2*P)/S + 1 
     W = width of matrix
     S = stride 
     P = padding
     F = filter size
    """
    # Separable computation has big O of 2n instead of n^2 
    # The resulting operation
    H = seperableConvolution(I=I,
                             K_v=G_v,
                             K_h=G_h,
                             imgWidth=width,
                             imgHeight=height,
                             W = W)

    return np.array(H).astype(np.uint8)

# Unit testing
if __name__=="__main__":
    print(cv2.getGaussianKernel(ksize=3, sigma=-1))
    start_time = time.time()
    I = readTextfile('file.txt')
    
    writeTextfile(GaussianBlur(I,(3,3),-1))

    print("--- %s seconds ---" % (time.time() - start_time))    
